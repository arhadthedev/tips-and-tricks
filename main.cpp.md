A file of a [[Desktop Application]] that prepares an environment by creating all modules of the application, connecting them with pointers and Qt signals, and creating a main window to run the show. A command line and environment variable processing is a part of environment configuration because they determine what modules will be created, how they are initialized and connected.

A user should be able to locate this file immediately.

Example of file organization and a header comment:

```cpp
/** Startup stuff.
 *
 * Copyright 2013 Oleg Yarigin <dralife@yandex.ru>.
 *
 * This file is part of MEAD.
 *
 * MEAD is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MEAD is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MEAD. If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include <version.h>

#include <cstdlib>  // EXIT_*
#include <cstring>  // strcmp
#include <iostream>

static bool
compare(const char *str1, const char *str2)
{
	return std::strcmp(str1, str2) != 0;
} 

static void
showHelp()
{
	std::cout <<
		"MEAD - Runs Windows applications on POSIX-comparatible systems."
		"Usage: mead [--version|--help] application [options]\n"
		"\t --version   - show version info and exit\n"
		"\t --help      - show this help and exit\n"
		"\n"
		"\t application - \n"
		"\t options     - application-specific options(are sent unparsed)\n\n"
}

static void
showAbout()
{
	std::cout <<
		"MEAD " MEAD_VERSION "\n"
		"Copyright (C) 2013  Oleg Yarigin <dralife@yandex.ru>\n"
		"This program comes with ABSOLUTELY NO WARRANTY; for details refer to\n"
		"GNU GPL v3 <http://www.gnu.org/licenses/gpl-3.0.html>.\n"
		"This is free software, and you are welcome to redistribute it\n"
		"under certain conditions; type `show c' for details.\n";
}

int
main(int argc, const char* argv[])
{
	if (argc > 1) {
		if (compare(argv[1], "--version")) {
			showAbout();
			return EXIT_SUCCESS;
		} else if (compare(argv[1], "--help"))
		{
			showHelp();
			return EXIT_SUCCESS;
		} else {
			return LoadLibraryA(argv[1], argc - 1, argv[1]);
		}
	} else {
		showHelp();
		return EXIT_SUCCESS;
	}
}
```

Another example of how to process a command line:

```cpp
/* main.cpp - program startup and out-of-domain routines
 *
 * Copyright (c) 2021 Oleg Iarygin <oleg@arhadthedev.net>
 *
 * Distributed under the MIT software license; see the accompanying
 * file LICENSE.txt or <https://www.opensource.org/licenses/mit-license.php>.
 */

#include "errors.hpp"
#include "grammar_processing.hpp"
#include "parser_config.hpp"
#include "version.h"  /* Generated by a root CMakeLists.txt into a build dir */
#include <CLI/CLI.hpp>
#include <optional>
#include <sstream>
#include <stdlib.h>
#include <string>
#include <variant>

struct command_line_flags {
	std::string config_path;
	std::string grammar_format;
};

struct input_data {
	std::string serialized_config;
	std::string grammar_format;
};

class normal_abortion {};
class abnormal_abortion {};

template<class... Ts> struct overloaded : Ts... { using Ts::operator()...; };
template<class... Ts> overloaded(Ts...) -> overloaded<Ts...>;

static std::variant<command_line_flags, normal_abortion, abnormal_abortion>
parse_command_line(int argc, char *argv[])
{
	CLI::App app{"generate direct code scannerless parser"};
	command_line_flags flags = {};

	std::string config_help = "Generation config file path";
	app.add_option("config", flags.config_path, config_help)->required();

	std::vector<std::string> formats = get_supported_grammar_formats();
	std::string format_help = "Format of a grammar from stdin";
	app.add_option("format", flags.grammar_format, format_help)->
	               transform(CLI::IsMember(formats, CLI::ignore_case))->
	               required();

	app.set_version_flag("--version", GRAMMAR2CODE_VERSION);

	try {
		app.parse(argc, argv);
		return flags;
	} catch (const CLI::Success &e) {
		app.exit(e);
		return normal_abortion{};
	} catch (const CLI::Error &e) {
		app.exit(e);
		return abnormal_abortion{};
	}
}

static std::string
pop_stream_content(std::istream &in)
{
	std::stringstream grammar;
	grammar << in.rdbuf();
	return std::move(grammar).str();
}

static std::optional<input_data>
process_flags(const command_line_flags &flags)
{
	input_data data;

	std::ifstream config_file(flags.config_path);
	if (!config_file) {
		std::cout << "config file error: " << get_last_error() << '\n';
		return {};
	}
	data.serialized_config = pop_stream_content(config_file);

	data.grammar_format = flags.grammar_format;

	return data;
}

static bool
process_input(const input_data &input)
{
	auto config_reading_result = deserialize_config(input.serialized_config);
	std::string serialized = pop_stream_content(std::cin);
	auto grammar_result = parse_grammar(serialized, input.grammar_format);
	bool is_processed = std::visit(overloaded {
		[](const parser_config &config, const grammar &grammar)
		{
			return true;
		},

		[](const positional_error &config_error, const grammar &)
		{
			std::cerr << "config file " << config_error << '\n';
			return false;
		},

		[](const parser_config &, const positional_error &grammar_error)
		{
			std::cerr << "grammar file " << grammar_error << '\n';
			return false;
		},

		[](const positional_error &config_error, const positional_error &)
		{
			std::cerr << "config file " << config_error << '\n';
			return false;
		}
	}, config_reading_result, grammar_result);
	return is_processed;
}

int
main(int argc, char *argv[])
{
	std::ios_base::sync_with_stdio(false);

	auto flags = parse_command_line(argc, argv);
	bool is_processed = std::visit(overloaded {
		[](const command_line_flags &flags)
		{
			std::optional<input_data> input = process_flags(flags);
			if (!input.has_value()) {
				return false;
			}
			return process_input(*input);
		},

		[](normal_abortion)
		{
			return true;
		},

		[](abnormal_abortion)
		{
			return false;
		}
	}, flags);
	return is_processed ? EXIT_SUCCESS : EXIT_FAILURE;
}
```